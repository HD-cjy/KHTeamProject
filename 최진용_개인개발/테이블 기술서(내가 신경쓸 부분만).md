## ERD상 구조 
![[Pasted image 20250531154135.png|340]]
### 테이블명: MESSAGE

| 컬럼명      | Data Type          | Nullable | Key | Description |
| -------- | ------------------ | -------- | --- | ----------- |
| ROOMNO   | NUMBER(11,0)       | NO       | PK  | 채팅방번호       |
| NO       | NUMBER(11,0)       | NO       | PK  | 메시지번호       |
| MESSAGE  | CLOB               | NO       |     | 메시지내용       |
| IMAGEURL | VARCHAR2(255 BYTE) | NO       |     | 이미지URL      |
| USERID   | VARCHAR2(255 BYTE) | NO       | FK  | 보낸사람아이디     |
| SENDTIME | DATE               | NO       |     | 보낸 시간       |

### 테이블명:CHAT_ROOM

| 컬럼이름      | Data Type          | Nullable | Key    | Description                           |
| --------- | ------------------ | -------- | ------ | ------------------------------------- |
| ROOMNO    | NUMBER(11,0)       | NO       | PK, FK | 채팅방번호                                 |
| USERID    | VARCHAR2(255 BYTE) | NO       | PK, FK | 유저 ID (ABC123@TEST123)                |
| LASTVISIT | VARCHAR2(20 BYTE)  | NO       |        | 마지막 방문 EX) ABC123(날짜시간)@TEST123(날짜시간) |
| CHATTYPE  | VARCHAR2(20 BYTE)  | NO       |        | 채팅타입 (이미지 채팅인지 일반 채팅인지)               |


SQL문 추가 
```sql
CREATE SEQUENCE CHAT_MESSAGE_SEQ
    MINVALUE 0
    MAXVALUE 9999999999999999999999999999
    INCREMENT BY 1
    START WITH 1
    NOCYCLE
    NOORDER
    NOCACHE;

```


테이블 재정리 
```sql
-- 모든 테이블의 의존성 역순으로 DROP (안전한 재구성을 위함)
-- 요청에 따라 CHAT_ROOM과 MESSAGE 먼저 DROP
DROP TABLE MESSAGE CASCADE CONSTRAINTS;
DROP TABLE CHAT_ROOM CASCADE CONSTRAINTS;

-- 나머지 테이블들 DROP
DROP TABLE SUBSCRIPTION CASCADE CONSTRAINTS;
DROP TABLE FAVORITE CASCADE CONSTRAINTS;
DROP TABLE USERQNA_INFO CASCADE CONSTRAINTS;
DROP TABLE ANSWER_INFO CASCADE CONSTRAINTS;
DROP TABLE SALL_REVIEW CASCADE CONSTRAINTS;
DROP TABLE PRODUCT CASCADE CONSTRAINTS;
DROP TABLE USER_INFO CASCADE CONSTRAINTS;

-- 테이블 생성

-- 1. USER_INFO (회원정보)
-- USERID는 다른 테이블에서 외래 키로 참조되므로 UNIQUE 제약조건을 추가합니다.
CREATE TABLE USER_INFO (
    USERNO      NUMBER(11)      PRIMARY KEY,
    USERID      VARCHAR2(255)   UNIQUE NOT NULL,
    PASSWORD    VARCHAR2(255)   NOT NULL,
    USER_NAME   VARCHAR2(20),
    EMAIL       VARCHAR2(255),
    STATUS      VARCHAR2(11),
    USERBANK    NUMBER(38),
    IS_BLOCK    VARCHAR2(11)
);

-- 2. PRODUCT (상품정보)
CREATE TABLE PRODUCT (
    PD_NUM          NUMBER(11)      PRIMARY KEY,
    PD_TITLE        VARCHAR2(255)   NOT NULL,
    PD_BOARD        CLOB,
    PD_PRICE        VARCHAR2(20), -- ERD에 따라 VARCHAR2로 지정
    LATITUDE        VARCHAR2(20),
    LONGTIDE        VARCHAR2(20),
    BIG_CATE        VARCHAR2(20),
    MIDDLE_CATE     VARCHAR2(20),
    SMALL_CATE      VARCHAR2(20), -- ERD의 SMALL_CTAE를 SMALL_CATE로 수정
    UPDATE_TIME     DATE,
    PD_RANK         NUMBER(4),
    PD_STATUS       VARCHAR2(20),
    IS_SUB          VARCHAR2(10)
);

-- 3. SALL_REVIEW (판매후기)
CREATE TABLE SALL_REVIEW (
    REVIEW_NO   NUMBER(11)      PRIMARY KEY,
    BUYERNO     NUMBER(11)      NOT NULL, -- 구매자 회원번호 (FK)
    USERNO      NUMBER(11)      NOT NULL, -- 리뷰 작성자 회원번호 (FK)
    PD_NUM      NUMBER(11)      NOT NULL, -- 상품 번호 (FK)
    REVIEW      CLOB,
    IMAGEURL    VARCHAR2(255),
    FOREIGN KEY (BUYERNO) REFERENCES USER_INFO(USERNO),
    FOREIGN KEY (USERNO) REFERENCES USER_INFO(USERNO),
    FOREIGN KEY (PD_NUM) REFERENCES PRODUCT(PD_NUM)
);

-- 4. ANSWER_INFO (답변정보)
CREATE TABLE ANSWER_INFO (
    ANSWERQNA_NUM   NUMBER(11)      PRIMARY KEY,
    USER_NO         NUMBER(11)      NOT NULL, -- 답변자 회원번호 (FK)
    ANSWER_TITLE    VARCHAR2(255),
    ANSWER_QNA      CLOB,
    ANSWER_IMG      VARCHAR2(255),
    PRODUCT_NUM     NUMBER(11)      NOT NULL, -- 상품 번호 (FK)
    ADMIN_NAME      VARCHAR2(20), -- ERD상 외래키 표시 없음
    FOREIGN KEY (USER_NO) REFERENCES USER_INFO(USERNO),
    FOREIGN KEY (PRODUCT_NUM) REFERENCES PRODUCT(PD_NUM)
);

-- 5. USERQNA_INFO (구매문의)
CREATE TABLE USERQNA_INFO (
    USERQNA_NUM     NUMBER(11)      PRIMARY KEY,
    USERNO          NUMBER(11)      NOT NULL, -- 문의 작성자 회원번호 (FK)
    USERQNA_TITLE   VARCHAR2(255),
    USERQNA         CLOB,
    EXUSER_NUM      NUMBER(11)      NOT NULL, -- ANSWER_INFO의 ANSWERQNA_NUM을 참조 (FK)
    USERQNA_IMG     VARCHAR2(255),
    FOREIGN KEY (USERNO) REFERENCES USER_INFO(USERNO),
    FOREIGN KEY (EXUSER_NUM) REFERENCES ANSWER_INFO(ANSWERQNA_NUM)
);

-- 6. FAVORITE (찜)
-- PD_NUM과 USER_NO로 복합 기본 키 구성
CREATE TABLE FAVORITE (
    PD_NUM      NUMBER(11)      NOT NULL, -- 상품 번호 (PK, FK)
    USER_NO     NUMBER(11)      NOT NULL, -- 회원 번호 (PK, FK)
    PRIMARY KEY (PD_NUM, USER_NO),
    FOREIGN KEY (PD_NUM) REFERENCES PRODUCT(PD_NUM),
    FOREIGN KEY (USER_NO) REFERENCES USER_INFO(USERNO)
);

-- 7. SUBSCRIPTION (구독신청)
-- BUYERNO와 PD_NUM으로 복합 기본 키 구성
CREATE TABLE SUBSCRIPTION (
    BUYERNO     NUMBER(11)      NOT NULL, -- 구매자 회원번호 (PK, FK)
    PD_NUM      NUMBER(11)      NOT NULL, -- 상품 번호 (PK, FK)
    USER_NO     NUMBER(11), -- ERD상 일반 컬럼으로 표시
    SUB_START   DATE,
    SUB_END     DATE,
    PRIMARY KEY (BUYERNO, PD_NUM),
    FOREIGN KEY (BUYERNO) REFERENCES USER_INFO(USERNO),
    FOREIGN KEY (PD_NUM) REFERENCES PRODUCT(PD_NUM)
);

-- 8. CHAT_ROOM (채팅방) - 요청에 따라 DROP 후 CREATE
-- IF EXISTS는 Oracle 12c 이상에서 지원됩니다. 이전 버전에서는 제거해야 합니다.
-- 더 넓은 호환성을 위해 "DROP TABLE CHAT_ROOM;"만 사용하고, 존재하지 않는 경우 오류를 무시하는 방식으로 처리하거나,
-- SQL 클라이언트에서 'whenever sqlerror continue' 같은 옵션을 사용할 수 있습니다.
DROP TABLE CHAT_ROOM;
CREATE TABLE CHAT_ROOM (
    ROOM_NO     NUMBER(11)      PRIMARY KEY,
    USER_ID     VARCHAR2(255)   NOT NULL, -- USER_INFO의 USERID를 참조 (FK)
    LASTVISIT   VARCHAR2(255), -- ERD에 따라 VARCHAR2로 지정
    CHAT_TYPE   VARCHAR2(20),
    FOREIGN KEY (USER_ID) REFERENCES USER_INFO(USERID)
);

-- 9. MESSAGE (메시지)
CREATE TABLE MESSAGE (
    NO          NUMBER(11)      PRIMARY KEY,
    ROOM_NO     NUMBER(11)      NOT NULL, -- CHAT_ROOM의 ROOM_NO를 참조 (FK)
    MESSAGE     CLOB,
    IMAGEURL    VARCHAR2(255),
    USER_ID     VARCHAR2(255)   NOT NULL, -- USER_INFO의 USERID를 참조 (FK)
    SENDTIME    DATE,
    FOREIGN KEY (ROOM_NO) REFERENCES CHAT_ROOM(ROOM_NO),
    FOREIGN KEY (USER_ID) REFERENCES USER_INFO(USERID)
);
```
### USER 더미데이터 
```sql
-- 1. USER_INFO 더미 데이터 삽입
-- USERNO는 시퀀스 목록에 USER_INFO에 대한 직접적인 시퀀스가 없으므로 일단 직접 할당합니다.
-- 실제 애플리케이션에서는 USERNO를 위한 시퀀스를 별도로 생성하거나,
-- DDL에서 IDENTITY 속성을 사용하여 자동 생성되도록 설정하는 것이 일반적입니다.
INSERT INTO DAMGEUN.USER_INFO (USERNO, USERID, PASSWORD, USERNAME, EMAIL, STATUS, USERRANK)
VALUES (1, 'user1', 'password1', '홍길동', 'user1@example.com', 'Y', 100);

INSERT INTO DAMGEUN.USER_INFO (USERNO, USERID, PASSWORD, USERNAME, EMAIL, STATUS, USERRANK)
VALUES (2, 'user2', 'password2', '김철수', 'user2@example.com', 'Y', 95);

INSERT INTO DAMGEUN.USER_INFO (USERNO, USERID, PASSWORD, USERNAME, EMAIL, STATUS, USERRANK)
VALUES (3, 'user3', 'password3', '이영희', 'user3@example.com', 'Y', 90);

INSERT INTO DAMGEUN.USER_INFO (USERNO, USERID, PASSWORD, USERNAME, EMAIL, STATUS, USERRANK)
VALUES (4, 'user4', 'password4', '박민수', 'user4@example.com', 'Y', 92);

INSERT INTO DAMGEUN.USER_INFO (USERNO, USERID, PASSWORD, USERNAME, EMAIL, STATUS, USERRANK)
VALUES (5, 'admin', 'admin123', '관리자', 'admin@example.com', 'Y', 0);

COMMIT;


```



## 5. Key Features Implementation Plan>)